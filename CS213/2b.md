## Virtual Processors (Threads)

A thread (or process) is a single stream of synchronous execution of a program. It can be stopped and resumed at any moment. For example, it could be stopped when it is waiting for an event, and resumed when the event fires.

Thus a thread gives the illusion of a single system.

We can have several threads running on a single CPU. 

When a thread is first created, it is called "`nascent`". It is waiting for a CPU to become available to run it. When this happens, the thread is then called "`running`".

There are 2 ways for a running thread to "stop" execution:

1. It can `block` itself (Cannot continue running until an event fires)
2. It can `yield` (Be nice and allow another thread to execute)

When a running thread yields, it becomes "`runnable`". This is very similar to nascent thread, so all threads that are either `nascent` or `runnable` are placed in a shared queue.

When a thread finishes executing, it is `dead`!!! We might hang onto its corpse if we are interested in its return value, but eventually we will cremate it and the thread is now `freed`.

### Thread operations - Create

This "forks" the control stream and starts a new thread. If a CPU is immediately available, the thread gets executed. Otherwise, it gets thrown as a `nascent` thread into the queue.

### Thread operations - Block/Unblock

Blocking a thread involves saving its current state, and then switching to a different thread. 

Unblocking a thread just places it in the queue, it doesnt immediately execute it. The thread is not "rescheduled" until it has been unblocked, usually based on some criteria.

A thread can block itself, but any thread can be unblocked from any other thread.

```c
uthread_block();
uthread_unblock(thread t);
```

### Thread operations - Join

A join is a special type of `block`. Some threads depend on the output (final value) of another thread, or it just might want a specific thread to finish before executing any further. So we `block` the current thread UNTIL the target thread completes. 

When the target dies, it only `unblocks` (queues) the first thread. So it it not necessarily run immediately afterwards.

```c
uthread_join(thread t, void** rtnValuePtr);
```




