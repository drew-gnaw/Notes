### Instance variables

Variables that are an instance of a class or struct. These are usually created dynamically, and many instances of the same class/struct can co-exist.

In Java, objects are instances of non-static variables of a class.

In C, structs are names variable groups, or one of their instances.

Accessing an instance variable requires a pointer to a particular object, as well as the variable name (to pick out the variable).

### Structs in C

A struct is a collection of variables of whatever type, allocated and accessed together.

Declaration of a struct uses the keyword 'struct' followed by the name:

```c
struct D {
    int e;
    int f;
}

// static, use . operator
struct D d0;

// dynamic, use -> operator
struct D* d1;
```

technically you could also access the 'e' field of a dynamically allocated struct using ```d1[0].e``` since the first part gets the value.

A struct has no padding in memory. In other words, the address of the struct IS the address of the first thing in the struct.

### Struct Allocation

Static structs are allocated by the compiler, while dynamic structs are allocated at runtime. The struct itself is allocated with a call to malloc.

```c
void foo() {
    d1 = malloc(sizeof(struct D));
}
```
If malloc returned 0x2000, then d1->e is stored at 0x2000 and d1->f is stored at 0x2004.

Struct members can be accessed using offset. The offset to each variable from base of struct is static. (In other words, the variables are always stored in the same order). As before, static and dynamic differ by an extra memory access, since getting a pointer requires an extra memory read.

In the case of the SM213, all offsets that we provide will be multiples of 4. Therefore, the offset we pass in is divided by 4 (so that we have more possible large offsets)

### Recap

Scalar: Access memory at the address.

Array: Base address in register, dynamic index in another register. Then we access element using base + 4*index.

Struct: Base address in register, static offset for each field. Access memory at base plus static offset. This is equivalent to accessing an array element with static index.

Why do we use the offset approach for structs, but index for arrays? It's because using index for structs just makes you waste extra lines that we don't need, since we KNOW the position of each field.

We can put WHATEVER THE FUCKKK WE WANT!! inside a struct (including other structs, pointers, etc.)

Note the difference between having a struct as a field and having a POINTER to a struct as a field! THe first one contains all the fields of the other struct, while the second one only has a single field which points to the head of the other struct.

In a struct, alignment is determined according to the largest member type. Structs can mix types using padding.

The size of a struct has to be the size of its alignment.
